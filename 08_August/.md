# üé® Make Matrix Beautiful

> ‚ö†Ô∏è **Educational Use Only**:
> This repository and its content are intended solely for educational purposes. Solutions are provided for learning, practice, and reference only. The problem statement and test cases are based on the [GeeksforGeeks problem](https://www.geeksforgeeks.org/problems/make-matrix-beautiful-1587115620/1).

<div align="center">
    <img src="https://img.shields.io/badge/GeeksforGeeks-298D46?style=for-the-badge&logo=geeksforgeeks&logoColor=white" alt="GFG Badge"/>
    <img src="https://img.shields.io/badge/Difficulty-Medium-yellow.svg?style=for-the-badge" alt="Difficulty Badge"/>
    <img src="https://img.shields.io/badge/Accuracy-64.75%25-green.svg?style=for-the-badge" alt="Accuracy Badge"/>
    <img src="https://img.shields.io/badge/Points-4-blue.svg?style=for-the-badge" alt="Points Badge"/>
    <img src="https://img.shields.io/badge/License-MIT-black.svg?style=for-the-badge" alt="License Badge"/>
</div>

---

## üìù Problem Statement

A beautiful matrix is defined as a square matrix in which the sum of elements in every row and every column is equal. Given a square matrix `mat[][]`, your task is to determine the **minimum number of operations** required to make the matrix beautiful.

In one operation, you are allowed to **increment the value of any single cell by 1**.

---

## üß™ Examples

### Example 1:
```
Input:
mat[][] = [[1, 2],
           [3, 4]]

Output: 4
```
<details>
<summary>üìñ Example Breakdown</summary>

* **Initial Matrix:**
    * Row 0 Sum: `1 + 2 = 3`
    * Row 1 Sum: `3 + 4 = 7`
    * Col 0 Sum: `1 + 3 = 4`
    * Col 1 Sum: `2 + 4 = 6`
* The maximum sum among all rows and columns is **7**. This is our target sum.
* **Operations for Row 0:**
    * Current sum is 3. Deficit is `7 - 3 = 4`.
    * We need 4 increments. Let's add 3 to `cell(0, 0)` and 1 to `cell(0, 1)`.
    * New `cell(0, 0)` = `1 + 3 = 4`.
    * New `cell(0, 1)` = `2 + 1 = 3`.
    * New Row 0: `[4, 3]`. Sum = 7.
* **Operations for Row 1:**
    * Current sum is 7. Deficit is `7 - 7 = 0`. No operations needed.
* **Final Matrix:**
    ```
    [[4, 3],
     [3, 4]]
    ```
* **Check Sums:**
    * Row 0 Sum: `4 + 3 = 7`
    * Row 1 Sum: `3 + 4 = 7`
    * Col 0 Sum: `4 + 3 = 7`
    * Col 1 Sum: `3 + 4 = 7`
* All sums are equal. The total operations performed was **4**.

</details>

### Example 2:
```
Input:
mat[][] = [[1, 2, 3],
           [4, 2, 3],
           [3, 2, 1]]

Output: 6
```

---

## ‚õìÔ∏è Constraints

> ```
> 1 ‚â§ mat.size() ‚â§ 900
> 0 ‚â§ mat[i][j] ‚â§ 10^6
> ```

---

## üí° Solution Approaches

The core idea is that to make the matrix beautiful by only incrementing values, every row and column must sum up to a **target value**. This target value must be the **maximum sum** found among all initial rows and columns. Any smaller target would require decreasing some values, which is not allowed.

The total number of operations will be the sum of differences between this target sum and each row's initial sum.

### C++ Solution

```cpp
// Intuition: To make a matrix beautiful, all row sums and column sums must be equal. Since we can only increment values, the final sum for each row and column must be at least the maximum sum that currently exists in any row or column. The goal is to find this target sum (the maximum of all initial row and column sums) and then calculate the total number of increments needed to make every row sum equal to this target sum. The sum of these increments will be the minimum number of operations.
// Approach:
// 1. Find the maximum sum among all rows and all columns. Let's call this 'maxSum'. This will be the target sum for every row and column in the beautiful matrix.
// 2. Iterate through each row of the matrix.
// 3. For each row, calculate its current sum.
// 4. The number of operations needed for that row is the difference between 'maxSum' and the row's current sum.
// 5. Add this difference to a running total, which represents the total minimum operations.
// 6. The final running total is the answer. It's sufficient to only balance the rows, as balancing all row sums to 'maxSum' guarantees that the sum of all elements in the matrix will be n * maxSum, which will also satisfy the column sum requirements.
// Time Complexity: O(N*N), where N is the number of rows (or columns). We traverse the matrix twice to find the max sum and once more to calculate the result.
// Space Complexity: O(1), as we only use a few variables to store sums and the result, not dependent on the input matrix size.
class Solution {
public:
    int findMinOpeartions(vector<vector<int> >& mat) {
        int n      = mat.size(); // Get the size of the square matrix (N x N)
        int result = 0;          // Initialize the total operations count
        int maxSum = 0;          // Stores the target sum for each row and column

        // Find maximum sum across all rows
        // This loop calculates the sum of each row and finds the maximum among them.
        for (int i = 0; i < n; i++) {
            int sum = 0; // Sum for the current row
            for (int j = 0; j < n; j++) {
                sum += mat[i][j]; // Add element to the row sum
            }
            maxSum = max(sum, maxSum); // Update maxSum if current row sum is greater
        }

        // Find maximum sum across all columns
        // This loop does the same for columns, ensuring maxSum is the max of ALL row/column sums.
        for (int j = 0; j < n; j++) {
            int sum = 0; // Sum for the current column
            for (int i = 0; i < n; i++) {
                sum += mat[i][j]; // Add element to the column sum
            }
            maxSum = max(sum, maxSum); // Update maxSum if current column sum is greater
        }

        // Calculate the total increments needed by making each row sum equal to maxSum.
        for (int i = 0; i < n; i++) {
            int sum = 0; // Sum for the current row
            for (int j = 0; j < n; j++) {
                sum += mat[i][j]; // Recalculate the row sum
            }
            result += (maxSum - sum); // Add the deficit for this row to the total operations
        }
        return result; // Return the total minimum operations
    }
};

/*
 *
 * Dry Run
 *
 * Input: mat[][] = [[1, 2, 3],
 * [4, 2, 3],
 * [3, 2, 1]]
 *
 * Initial values:
 * n = 3
 * result = 0
 * maxSum = 0
 *
 * 1. Find maximum sum across all rows:
 * - Row 0 sum: 1 + 2 + 3 = 6.  maxSum = max(0, 6) = 6.
 * - Row 1 sum: 4 + 2 + 3 = 9.  maxSum = max(6, 9) = 9.
 * - Row 2 sum: 3 + 2 + 1 = 6.  maxSum = max(9, 6) = 9.
 * After this loop, maxSum = 9.
 *
 * 2. Find maximum sum across all columns:
 * - Col 0 sum: 1 + 4 + 3 = 8.  maxSum = max(9, 8) = 9.
 * - Col 1 sum: 2 + 2 + 2 = 6.  maxSum = max(9, 6) = 9.
 * - Col 2 sum: 3 + 3 + 1 = 7.  maxSum = max(9, 7) = 9.
 * After this loop, maxSum remains 9.
 *
 * 3. Sum of operations across all rows:
 * - result is currently 0.
 * - For Row 0 (sum = 6): result += (9 - 6) => result = 3.
 * - For Row 1 (sum = 9): result += (9 - 9) => result = 3.
 * - For Row 2 (sum = 6): result += (9 - 6) => result = 3 + 3 = 6.
 *
 * 4. Return result:
 * The final value of result is 6.
 *
 * Output: 6
 *
 */
```

### Java Solution

```java
// Intuition: To make a matrix beautiful, all row sums and column sums must be equal. Since we can only increment values, the final sum for each row and column must be at least the maximum sum that currently exists in any row or column. The goal is to find this target sum (the maximum of all initial row and column sums) and then calculate the total number of increments needed to make every row sum equal to this target sum. The sum of these increments will be the minimum number of operations.
// Approach:
// 1. Find the maximum sum among all rows and all columns. Let's call this 'maxSum'. This will be the target sum for every row and column in the beautiful matrix.
// 2. Iterate through each row of the matrix.
// 3. For each row, calculate its current sum.
// 4. The number of operations needed for that row is the difference between 'maxSum' and the row's current sum.
// 5. Add this difference to a running total, which represents the total minimum operations.
// 6. The final running total is the answer. It's sufficient to only balance the rows, as balancing all row sums to 'maxSum' guarantees that the sum of all elements in the matrix will be n * maxSum, which will also satisfy the column sum requirements.
// Time Complexity: O(N*N), where N is the number of rows (or columns). We traverse the matrix twice to find the max sum and once more to calculate the result.
// Space Complexity: O(1), as we only use a few variables to store sums and the result, not dependent on the input matrix size.
class Solution {
    public static int findMinOpeartions(int[][] mat) {
        int n      = mat.length; // Get the size of the square matrix (N x N)
        int result = 0;          // Initialize the total operations count
        int maxSum = 0;          // Stores the target sum for each row and column

        // Find maximum sum across all rows
        // This loop calculates the sum of each row and finds the maximum among them.
        for (int i = 0; i < n; i++) {
            int sum = 0; // Sum for the current row
            for (int j = 0; j < n; j++) {
                sum += mat[i][j]; // Add element to the row sum
            }
            maxSum = Math.max(sum, maxSum); // Update maxSum if current row sum is greater
        }

        // Find maximum sum across all columns
        // This loop does the same for columns, ensuring maxSum is the max of ALL row/column sums.
        for (int j = 0; j < n; j++) {
            int sum = 0; // Sum for the current column
            for (int i = 0; i < n; i++) {
                sum += mat[i][j]; // Add element to the column sum
            }
            maxSum = Math.max(sum, maxSum); // Update maxSum if current column sum is greater
        }

        // Calculate the total increments needed by making each row sum equal to maxSum.
        for (int i = 0; i < n; i++) {
            int sum = 0; // Sum for the current row
            for (int j = 0; j < n; j++) {
                sum += mat[i][j]; // Recalculate the row sum
            }
            result += (maxSum - sum); // Add the deficit for this row to the total operations
        }
        return result; // Return the total minimum operations
    }
}
/*
 *
 * Dry Run
 *
 * Input: mat[][] = {{1, 2, 3},
 * {4, 2, 3},
 * {3, 2, 1}}
 *
 * Initial values:
 * n = 3
 * result = 0
 * maxSum = 0
 *
 * 1. Find maximum sum across all rows:
 * - Row 0 sum: 1 + 2 + 3 = 6.  maxSum = Math.max(0, 6) = 6.
 * - Row 1 sum: 4 + 2 + 3 = 9.  maxSum = Math.max(6, 9) = 9.
 * - Row 2 sum: 3 + 2 + 1 = 6.  maxSum = Math.max(9, 6) = 9.
 * After this loop, maxSum = 9.
 *
 * 2. Find maximum sum across all columns:
 * - Col 0 sum: 1 + 4 + 3 = 8.  maxSum = Math.max(9, 8) = 9.
 * - Col 1 sum: 2 + 2 + 2 = 6.  maxSum = Math.max(9, 6) = 9.
 * - Col 2 sum: 3 + 3 + 1 = 7.  maxSum = Math.max(9, 7) = 9.
 * After this loop, maxSum remains 9.
 *
 * 3. Sum of operations across all rows:
 * - result is currently 0.
 * - For Row 0 (sum = 6): result += (9 - 6) => result = 3.
 * - For Row 1 (sum = 9): result += (9 - 9) => result = 3.
 * - For Row 2 (sum = 6): result += (9 - 6) => result = 3 + 3 = 6.
 *
 * 4. Return result:
 * The final value of result is 6.
 *
 * Output: 6
 *
 */
```

---

## üéØ Key Insights

* **Target Sum**: The target sum for every row and column in the final "beautiful" matrix must be the maximum of all initial row and column sums. This is because we can only increment cell values.
* **Sufficient Condition**: It is sufficient to just calculate the total increments needed to make each row's sum equal to the target sum. If all row sums are balanced to the target `maxSum`, the sum of all elements in the matrix becomes `N * maxSum`. This implicitly ensures that the sum of all column sums also equals `N * maxSum`. Since the total sum is distributed correctly, and we've ensured each row meets the target, the columns must also be balanced. The total deficit in column sums will equal the total deficit in row sums.

---

## üîé Further Exploration

* [Find sum of all right diagonal elements of a Matrix](https://www.geeksforgeeks.org/problems/find-sum-of-all-right-diagonal-elements-of-a-matrix/0)
* [Row with max 1s](https://www.geeksforgeeks.org/problems/row-with-max-1s0023/1)
* [Spirally traversing a matrix](https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1)

---

## üìö References

* **Original Problem:** [https://www.geeksforgeeks.org/problems/make-matrix-beautiful-1587115620/1](https://www.geeksforgeeks.org/problems/make-matrix-beautiful-1587115620/1)

---

## üë®‚Äçüíª Author

* **GitHub:** [imnilesh18](https://github.com/imnilesh18)

---

## üè∑Ô∏è Tags

<div align="center">
    <img src="https://img.shields.io/badge/Matrix-8A2BE2?style=for-the-badge" alt="Matrix Tag"/>
    <img src="https://img.shields.io/badge/Array-4B0082?style=for-the-badge" alt="Array Tag"/>
    <img src="https://img.shields.io/badge/Greedy-FFD700?style=for-the-badge" alt="Greedy Tag"/>
    <img src="https://img.shields.io/badge/GeeksforGeeks-298D46?style=for-the-badge" alt="GeeksforGeeks Tag"/>
</div>

---

## üìú License

This project is licensed under the **MIT License**.

> **Note**: This is for educational purposes only. The solutions are provided for learning and reference. Always try to solve the problem on your own first.