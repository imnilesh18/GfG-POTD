# Possible Words From Phone Digits

---

<div align="center">
  <a href="https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1">
    <img src="https://img.shields.io/badge/GeeksforGeeks-298D46?style=for-the-badge&logo=geeksforgeeks&logoColor=white" alt="GFG">
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge" alt="Difficulty">
  <img src="https://img.shields.io/badge/Accuracy-52.79%25-brightgreen?style=for-the-badge" alt="Accuracy">
  <img src="https://img.shields.io/badge/Points-4-blue?style=for-the-badge" alt="Points">
  <img src="https://img.shields.io/badge/License-MIT-green.svg?style=for-the-badge" alt="License">
</div>

‚ö†Ô∏è **Educational Use Only**:
This repository and its content are intended solely for educational purposes.
Solutions are provided for learning, practice, and reference only.
Problem statement and test cases are based on the [GeeksforGeeks problem](https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1).

---

## üìù Problem Statement

You are given a keypad (as shown in the diagram) and an array `arr[]` containing digits, your task is to **list all possible words** in **any order** which can be generated by pressing numbers in `arr[]` sequentially.

**Note**: Number `0` and `1` do not map to any letters.

You can return the words in any order, the driver code will print them in sorted order.

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" width="200px" alt="keypad">
</div>

---

## üìñ Examples

### Example 1:

```
Input: arr[] = [2, 3]
Output: [ad, ae, af, bd, be, bf, cd, ce, cf]
Explanation: When we press 2 and 3 total 3 x 3 = 9 possible words formed.
```

### Example 2:

```
Input: arr[] = [2]
Output: [a, b, c]
Explanation: When we press 2 total 3 possible words formed.
```

<details>
<summary>üìñ Example Breakdown</summary>

Let's walk through the first example: `arr[] = [2, 3]`

1.  **Start with the first digit `2`:** The letters for `2` are "abc".
2.  **Start with the second digit `3`:** The letters for `3` are "def".

Now, we combine the letters from each position:

- `a` from `2` can be combined with `d`, `e`, `f` from `3` to form `ad`, `ae`, `af`.
- `b` from `2` can be combined with `d`, `e`, `f` from `3` to form `bd`, `be`, `bf`.
- `c` from `2` can be combined with `d`, `e`, `f` from `3` to form `cd`, `ce`, `cf`.

This gives us a total of `3 * 3 = 9` possible words.

</details>

---

## ‚õìÔ∏è Constraints

- `1 ‚â§ arr.size() ‚â§ 9`
- `0 ‚â§ arr[i] ‚â§ 9`

---

## üí° Solution Approaches

### C++ Solution

```cpp
// Intuition: The problem asks for all possible letter combinations from a phone number. This suggests a recursive approach, where we explore all possible paths. At each step, we have a choice of characters for the current digit. We can append one character and then recurse for the next digit. This "choose, explore, unchoose" pattern is a classic backtracking problem.
// Approach: We use a recursive helper function `solve`. The function takes the current index of the digit array, the current combination string, a map of digits to letters, and a result vector. The base case is when the index reaches the end of the digit array. In the recursive step, we get the letters for the current digit. If there are no letters (for 0 or 1), we skip to the next digit. Otherwise, we loop through each character, append it to the current string, recurse for the next digit, and then backtrack by removing the character.
// Time Complexity: O(4^n), where n is the number of digits in the input array. This is because each digit can have up to 4 characters, and we explore all combinations.
// Space Complexity: O(n) for the recursion stack. The result vector is not counted in the auxiliary space.
class Solution {
  public:
    // Helper function to generate combinations using recursion and backtracking
    void solve(vector<int>& arr, int index, string& current,
               unordered_map<int, string>& padMap, vector<string>& res) {

        // Base case: If we have processed all digits in the input array.
        if (index == arr.size()) {
            // Add the generated word to the result list, but only if it's not empty.
            if (!current.empty()) {
                res.push_back(current);
            }
            return;
        }

        int digit = arr[index];
        string letters = padMap[digit]; // Get letters for the current digit.

        // If the digit has no mapping (like 0 or 1), letters will be empty.
        if (letters.empty()) {
            // Skip the current digit and move to the next one.
            solve(arr, index + 1, current, padMap, res);
        } else {
            // Iterate through all characters mapped to the current digit.
            for (char ch : letters) {
                // 1. Choose: Append the character.
                current.push_back(ch);

                // 2. Explore: Recurse for the next digit.
                solve(arr, index + 1, current, padMap, res);

                // 3. Unchoose (Backtrack): Remove the last character to explore other paths.
                current.pop_back();
            }
        }
    }

    // Main function to initiate the process
    vector<string> possibleWords(vector<int>& arr) {
        vector<string> res;
        if (arr.empty()) {
            return res;
        }

        // Using a hashmap to map digits to letters
        unordered_map<int, string> padMap;
        padMap[2] = "abc";
        padMap[3] = "def";
        padMap[4] = "ghi";
        padMap[5] = "jkl";
        padMap[6] = "mno";
        padMap[7] = "pqrs";
        padMap[8] = "tuv";
        padMap[9] = "wxyz";
        // Note: Accessing padMap for 0 or 1 will return a default empty string.

        string current = "";
        solve(arr, 0, current, padMap, res);
        return res;
    }
};

/*
*
* Dry Run
*
* arr = [2, 3]
*
* solve([2, 3], 0, "", ...)
* digit = 2, letters = "abc"
* ch = 'a'
* current = "a"
* solve([2, 3], 1, "a", ...)
* digit = 3, letters = "def"
* ch = 'd'
* current = "ad"
* solve([2, 3], 2, "ad", ...) -> res.push_back("ad")
* current = "a"
* ch = 'e'
* current = "ae"
* solve([2, 3], 2, "ae", ...) -> res.push_back("ae")
* current = "a"
* ch = 'f'
* current = "af"
* solve([2, 3], 2, "af", ...) -> res.push_back("af")
* current = "a"
* current = ""
*
* (similar steps for 'b' and 'c')
*
* Final Result: [ad, ae, af, bd, be, bf, cd, ce, cf]
*
*/
```

---

## üîë Key Insights

The problem is a classic example of **backtracking**. The core idea is to build the solution step-by-step (in this case, character-by-character) and abandon a path as soon as it's clear it won't lead to a solution.

- **Recursive Structure**: The problem can be broken down into smaller, self-similar subproblems. Generating words for `[2, 3, 4]` is like taking each letter for `2` and appending all possible words for `[3, 4]`.
- **Backtracking**: The `current.pop_back()` step is crucial. After exploring all paths starting with a certain character, we need to "undo" our choice to explore other possibilities.

---

## üöÄ Further Exploration

- [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) (LeetCode version of this problem)
- [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) (Another classic backtracking problem)
- [Permutations](https://leetcode.com/problems/permutations/) (Explore all permutations of a set of numbers)

---

## üìö References

- [Original GeeksforGeeks Problem](https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1)

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)

---

## üè∑Ô∏è Tags

`backtracking` `recursion` `string` `geeksforgeeks`

---

## üìú License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

**A strong educational use reminder**:
The code and explanations in this repository are for educational purposes. They are meant to help you understand the problem and the solution approach. It's highly recommended that you try to solve the problem on your own before looking at the solution.
